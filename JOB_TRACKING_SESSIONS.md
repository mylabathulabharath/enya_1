# Job Tracking and Sessions - Complete Explanation

## Overview

This document explains how job tracking and "sessions" work in this distributed video processing system. The system uses a multi-tier architecture where jobs are tracked across different components.

## Architecture Overview

```
┌─────────────┐         ┌──────────────┐         ┌─────────────────┐
│   Frontend  │────────▶│  Node.js     │────────▶│  Remote API     │
│  (React)    │         │  Server      │         │  Server (Python)│
│             │         │              │         │                 │
│  Dashboard  │         │  JobManager  │         │  Jobs Dict      │
│             │         │              │         │                 │
└─────────────┘         └──────────────┘         └─────────────────┘
                            │                            │
                            │                            │
                            ▼                            ▼
                    ┌──────────────┐         ┌─────────────────┐
                    │  data/       │         │  Pipeline       │
                    │  jobs.json   │         │  Execution      │
                    │  (Persistent)│         │  (Docker)       │
                    └──────────────┘         └─────────────────┘
```

## What is a "Session"?

In this context, a "session" refers to the **lifecycle of a job** as it moves through the system. Each job has:

1. **Local Job ID** (UUID) - Generated by Node.js server
2. **Remote Job ID** (e.g., `job_1234567890`) - Generated by Remote API server
3. **Job State** - Tracks status, progress, errors, etc.

### Job Session Flow

```
1. User creates job in Frontend
   ↓
2. Node.js server creates LOCAL job (UUID)
   ↓
3. Node.js server connects to Remote API server
   ↓
4. Remote API server creates REMOTE job (job_xxx)
   ↓
5. Remote API server starts pipeline execution
   ↓
6. Node.js server polls Remote API server for status
   ↓
7. Job completes, status is synced back
```

## Components Explained

### 1. Frontend (React Dashboard)

**Purpose**: User interface to view and manage jobs

**What it stores**:
- Job list fetched from Node.js server
- UI state (selected tabs, filters)
- **No persistent storage** - everything is fetched from backend

**Session Management**:
- Fetches jobs every 10 seconds
- Shows refresh button for manual sync
- Displays job status, progress, and actions

### 2. Node.js Server (JobManager)

**Purpose**: Central job management and coordination

**What it stores**:
- **Local jobs** in memory (Map) and persistent file (`data/jobs.json`)
- Maps local job IDs to remote job IDs
- Tracks job status, progress, errors
- Stores node information

**Session Management**:
- **Persistent Storage**: Jobs are saved to `data/jobs.json` file
  - Automatically loaded on server start
  - Saved after each job update (debounced to avoid too many writes)
  - Survives server restarts

**Key Methods**:
- `addJob()` - Creates new job, saves to file
- `updateJob()` - Updates job status, saves to file
- `getJob()` - Retrieves job from memory
- `pollRemoteJobStatus()` - Polls remote server for job updates

### 3. Remote API Server (Python Flask)

**Purpose**: Executes pipeline jobs in Docker containers

**What it stores**:
- **Remote jobs** in memory (Python dict)
- Job execution state
- Pipeline output and errors
- **NOT persistent** - Jobs are lost on server restart

**Session Management**:
- Creates job with unique ID (e.g., `job_1234567890`)
- Executes pipeline in background thread
- Updates job status as pipeline progresses
- Stores output file information

**Key Endpoints**:
- `POST /jobs` - Create new job
- `GET /jobs/<job_id>` - Get job status
- `GET /jobs/<job_id>/outputs` - List output files
- `GET /jobs/<job_id>/download/<filename>` - Download output

## Job Tracking Flow (Detailed)

### Step 1: Job Creation

```javascript
// Frontend
const job = await jobsAPI.create({
  inputMethod: 'manual',
  manualPath: '/path/to/video.mp4',
  nodeId: 'node-123',
  // ... other params
})

// Node.js Server
const localJob = {
  id: 'uuid-1234-5678',  // Local ID
  nodeId: 'node-123',
  status: 'pending',
  // ... other fields
}
await jobManager.addJob(localJob)  // Saves to data/jobs.json

// Remote API Server
const remoteJob = {
  id: 'job_1234567890',  // Remote ID
  status: 'pending',
  // ... other fields
}
jobs[remoteJob.id] = remoteJob  // Stored in memory
```

### Step 2: Job Execution

```javascript
// Node.js Server connects to Remote API Server
const remoteJob = await apiClient.createJob(jobData)

// Store remote job ID in local job
await jobManager.updateJob(localJobId, {
  remoteJobId: remoteJob.id  // Links local and remote jobs
})

// Start polling in background
pollRemoteJobStatus(localJobId, node, remoteJob.id)
```

### Step 3: Status Polling

```javascript
// Node.js Server polls Remote API Server every 5 seconds
while (job not complete) {
  const remoteJob = await apiClient.getJob(remoteJobId)
  
  // Update local job with remote status
  await jobManager.updateJob(localJobId, {
    status: remoteJob.status,
    progress: remoteJob.progress,
    error: remoteJob.error
  })
  
  await sleep(5000)  // Wait 5 seconds
}
```

### Step 4: Job Completion

```javascript
// Remote API Server
jobs[job_id]['status'] = 'completed'
jobs[job_id]['progress'] = 100
jobs[job_id]['output_files'] = find_output_files(job)

// Node.js Server (via polling)
await jobManager.updateJob(localJobId, {
  status: 'completed',
  progress: 100,
  outputFiles: remoteJob.output_files
})
```

## Persistent Storage

### Node.js Server (JobManager)

**Location**: `data/jobs.json`

**Format**:
```json
[
  {
    "id": "uuid-1234-5678",
    "remoteJobId": "job_1234567890",
    "nodeId": "node-123",
    "status": "completed",
    "progress": 100,
    "inputMethod": "manual",
    "manualPath": "/path/to/video.mp4",
    "createdAt": "2024-01-01T12:00:00.000Z",
    "updatedAt": "2024-01-01T12:30:00.000Z",
    "outputFiles": [
      {
        "name": "final_without_post_process__video.mp4",
        "size": 12345678,
        "path": "/workspace/output_videos_latest/video/final_without_post_process__video.mp4"
      }
    ]
  }
]
```

**Benefits**:
- Jobs survive server restarts
- Can recover jobs if remote job ID is lost
- Historical job data is preserved

**Limitations**:
- File-based storage (not a database)
- All jobs in one file (could be slow with many jobs)
- No automatic cleanup of old jobs

### Remote API Server

**Location**: In-memory Python dictionary

**Format**:
```python
jobs = {
  'job_1234567890': {
    'id': 'job_1234567890',
    'status': 'completed',
    'progress': 100,
    'output_files': [...],
    # ... other fields
  }
}
```

**Benefits**:
- Fast access (in-memory)
- Simple implementation

**Limitations**:
- **NOT persistent** - Jobs are lost on server restart
- Limited by available memory
- No historical data

## Session Recovery

### Problem: Jobs Lost After Server Restart

If the Node.js server restarts:
- ✅ Local jobs are recovered from `data/jobs.json`
- ❌ Remote jobs are lost (if Remote API server restarted)

### Solution: Job Recovery

The refresh endpoint can recover jobs:

```javascript
// If job has no remoteJobId, try to find it on remote node
if (!job.remoteJobId && job.nodeId) {
  const remoteJobs = await apiClient.listJobs()
  
  // Find matching job by input parameters
  const matchingJob = remoteJobs.find(rj => {
    return rj.input_method === job.inputMethod &&
           rj.manual_path === job.manualPath
  })
  
  if (matchingJob) {
    // Recover remote job ID
    await jobManager.updateJob(job.id, {
      remoteJobId: matchingJob.id
    })
  }
}
```

## Common Issues and Solutions

### Issue 1: Job Shows as "Failed" But Pipeline is Running

**Cause**: Connection lost between Node.js server and Remote API server

**Solution**:
1. Click refresh button to manually sync status
2. Check server logs for connection errors
3. Verify Remote API server is running and accessible

### Issue 2: Refresh Button Not Working

**Possible Causes**:
1. Job has no `remoteJobId` stored
2. Node not found or offline
3. Connection to Remote API server failed

**Solution**:
1. Check server logs for detailed error messages
2. Verify node is online and accessible
3. Try job recovery (system will attempt to find matching remote job)

### Issue 3: Jobs Lost After Server Restart

**Cause**: Remote API server restarted, losing in-memory jobs

**Solution**:
1. Jobs are recovered from `data/jobs.json` on Node.js server restart
2. Use refresh button to reconnect to remote jobs (if they still exist)
3. If remote jobs are lost, they cannot be recovered (limitation of in-memory storage)

## Best Practices

### 1. Regular Backups

Backup `data/jobs.json` regularly:
```bash
cp data/jobs.json data/jobs.json.backup
```

### 2. Monitor Server Logs

Watch for connection errors:
```bash
# Node.js server logs
tail -f server.log | grep "JobManager"

# Remote API server logs
docker logs <container-name> | grep "API"
```

### 3. Use Refresh Button

If a job shows incorrect status:
1. Click refresh button
2. Check error message (if any)
3. Verify Remote API server is accessible

### 4. Clean Up Old Jobs

Periodically clean up completed/failed jobs:
- Delete old jobs from `data/jobs.json`
- Or implement automatic cleanup based on age

## Future Improvements

1. **Database Storage**: Replace file-based storage with database (PostgreSQL, MongoDB)
2. **Remote Job Persistence**: Add persistent storage to Remote API server
3. **WebSocket Updates**: Replace polling with WebSocket for real-time updates
4. **Job History**: Track job execution history and logs
5. **Automatic Recovery**: Automatically recover jobs on server restart
6. **Job Queuing**: Implement job queue system for better job management

## Summary

- **Sessions** = Job lifecycles tracked across multiple components
- **Local Jobs** = Stored in Node.js server (persistent)
- **Remote Jobs** = Stored in Remote API server (in-memory, not persistent)
- **Job Tracking** = Local job ID + Remote job ID mapping
- **Status Sync** = Polling Remote API server every 5 seconds
- **Recovery** = Refresh button can recover lost remote job IDs
- **Persistence** = Jobs survive Node.js server restarts, but not Remote API server restarts

The system is designed to handle temporary connection issues gracefully, but jobs can be lost if the Remote API server restarts (since it uses in-memory storage).

